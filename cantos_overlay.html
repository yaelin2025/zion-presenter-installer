<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zion Presenter - Visor</title>
    <link rel="icon" type="image/png" href="img/favicon.png">
    <link rel="apple-touch-icon" href="img/favicon.png">
    <link rel="manifest" href="manifest.json">
    <!-- Fuente Local / Fallback -->
    <link href="css/fonts.css" rel="stylesheet">
    <style>
        :root {
            --font-family: 'BenchNine', sans-serif;
            --text-transform: none;
            --text-shadow: 10px;
            --margin: 50px;
            --margin-x: 80px;
            /* Nuevo: Margen horizontal independiente */
            --transition-duration: 1s;
            --bg-dim: 0;
            --bg-blur: 0px;
            --text-color: #ffffff;
            --shadow-color: #000000;
        }

        #mainViewport {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            z-index: 20;
            overflow: hidden;
            pointer-events: none;
        }

        #mainViewport>* {
            pointer-events: auto;
        }

        #contentArea {
            flex: 1;
            position: relative;
            width: 100%;
            overflow: hidden;
        }

        body {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background-color: transparent;
            /* Transparente por defecto para seguridad en OBS */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Capa de Fondo (Imagen) */
        #bgLayer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            z-index: -2;
            opacity: 0;
            /* Oculto si no hay imagen */
            transition: opacity 1s ease, filter 0.3s ease, transform 0.3s ease;
            will-change: opacity, filter;
        }

        video#bgVideo {
            will-change: opacity;
            filter: none !important;
            /* Desactivar blur en videos para rendimiento */
        }

        /* Capa de Oscurecimiento (Separada para afectar a ambos) */
        /* Eliminado bgLayer::after para usar un div separado */

        /* Contenedor de Texto */
        #textContainer {
            width: 100%;
            height: 100%;
            padding: var(--margin) var(--margin-x);
            /* Vertical | Horizontal */
            /* Eliminados padding-left/right fijos */
            box-sizing: border-box;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;

            /* Tipograf√≠a Din√°mica */
            font-family: var(--font-family);
            text-transform: var(--text-transform);
            color: var(--text-color);
            font-weight: var(--font-weight, 800);
            letter-spacing: -2px;
            /* Look compacto de Proyektor */

            /* Sombra Multinivel Din√°mica (Vinculada al Slider) */
            text-shadow:
                0 0 calc(var(--text-shadow) * 0.1px) var(--shadow-color),
                0 0 calc(var(--text-shadow) * 0.5px) var(--shadow-color),
                0 0 calc(var(--text-shadow) * 1px) var(--shadow-color),
                0 calc(var(--text-shadow) * 0.2px) calc(var(--text-shadow) * 1.8px) var(--shadow-color);

            /* Transiciones */
            transition: opacity var(--transition-duration) ease, transform var(--transition-duration) ease;

            /* GPU ACCELERATION (Fix Windows Flicker) */
            backface-visibility: hidden;
            perspective: 1000px;
            will-change: transform, opacity;
            transform: translateZ(0);
            z-index: 2;
        }

        #textContent {
            white-space: pre-wrap;
            /* Respetar saltos de l√≠nea manuales */
            overflow-wrap: break-word;
            /* Romper palabras largas si es necesario */
            word-wrap: break-word;
            /* Compatibilidad */
            max-width: 100%;
            /* Asegurar que no se salga del contenedor */
            line-height: var(--line-height, 0.95);
            /* Pro Look: Interlineado ajustable desde panel */

            /* Anti-aliasing para texto suave en transiciones */
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* Estados de Transici√≥n */
        /* Estado Base (Oculto) seg√∫n el efecto */

        /* ========================================  
           ANIMACI√ìN 1: FADE (Suave y Profesional)
           ======================================== */
        #textContainer.effect-fade {
            opacity: 0;
            transform: scale(1) translateZ(0);
        }

        #textContainer.effect-fade.visible {
            opacity: 1 !important;
            transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1) !important;
        }

        /* ========================================  
           ANIMACI√ìN 2: ZOOM (MANTENER - Ya optimizada)
           ======================================== */
        #textContainer.effect-zoom {
            opacity: 0;
            transform: scale(0.65) translateZ(0);
            will-change: transform, opacity;
            transform-origin: center center;
        }

        #textContainer.effect-zoom.visible {
            transition-timing-function: cubic-bezier(0.16, 1, 0.3, 1) !important;
        }

        /* ========================================  
           ANIMACI√ìN 3: WIPE UP (Revelaci√≥n Vertical)
           Efecto de cortina que se levanta
           ======================================== */
        #textContainer.effect-slide-up {
            opacity: 0;
            transform: translateY(100%) scaleY(0.3) translateZ(0);
            transform-origin: bottom center;
            filter: brightness(0.5);
            will-change: transform, opacity, filter;
        }

        #textContainer.effect-slide-up.visible {
            opacity: 1 !important;
            transform: translateY(0) scaleY(1) translateZ(0) !important;
            filter: brightness(1) !important;
            transition-timing-function: cubic-bezier(0.25, 0.46, 0.45, 0.94) !important;
        }

        /* ========================================  
           ANIMACI√ìN 4: SPIRAL IN (Entrada en Espiral)
           Movimiento vortex cinematogr√°fico
           ======================================== */
        #textContainer.effect-slide-left {
            opacity: 0;
            transform: translateX(-300px) translateY(150px) rotate(-180deg) scale(0.4) translateZ(0);
            filter: blur(10px);
            will-change: transform, opacity, filter;
        }

        #textContainer.effect-slide-left.visible {
            opacity: 1 !important;
            transform: translateX(0) translateY(0) rotate(0deg) scale(1) translateZ(0) !important;
            filter: blur(0px) !important;
            transition-timing-function: cubic-bezier(0.34, 1.3, 0.64, 1) !important;
        }

        /* ========================================  
           ANIMACI√ìN 5: LENS FLARE (Destello de Luz)
           Explosi√≥n de brillo desde el centro
           ======================================== */
        #textContainer.effect-slide-right {
            opacity: 0;
            transform: scale(3) translateZ(0);
            filter: blur(40px) brightness(3) saturate(0);
            will-change: transform, opacity, filter;
        }

        #textContainer.effect-slide-right.visible {
            opacity: 1 !important;
            transform: scale(1) translateZ(0) !important;
            filter: blur(0px) brightness(1) saturate(1) !important;
            transition-timing-function: cubic-bezier(0.19, 1, 0.22, 1) !important;
        }

        /* ========================================  
           ANIMACI√ìN 6: ROTATE-IN (MANTENER - Giro 3D)
           ======================================== */
        #textContainer.effect-rotate-in {
            opacity: 0;
            transform: perspective(1200px) rotateX(-25deg) scale(0.85) translateZ(0);
            will-change: transform, opacity;
            transform-origin: center center;
        }

        #textContainer.effect-rotate-in.visible {
            opacity: 1 !important;
            transform: perspective(1200px) rotateX(0deg) scale(1) translateZ(0) !important;
            transition-timing-function: cubic-bezier(0.34, 1.4, 0.64, 1) !important;
        }

        /* ========================================  
           ANIMACI√ìN 7: PARTICLE BURST (Explosi√≥n de Part√≠culas)
           Entrada explosiva desde m√∫ltiples direcciones
           ======================================== */
        #textContainer.effect-blur-fade {
            opacity: 0;
            transform: scale(0.1) rotate(360deg) translateZ(0);
            filter: blur(30px) brightness(2);
            will-change: transform, filter, opacity;
        }

        #textContainer.effect-blur-fade.visible {
            opacity: 1 !important;
            transform: scale(1) rotate(0deg) translateZ(0) !important;
            filter: blur(0px) brightness(1) !important;
            transition-timing-function: cubic-bezier(0.68, -0.55, 0.265, 1.55) !important;
        }

        /* ========================================  
           ANIMACI√ìN 8: LIQUID MORPH (Deformaci√≥n L√≠quida)
           Transformaci√≥n org√°nica fluida
           ======================================== */
        #textContainer.effect-elastic {
            opacity: 0;
            transform: scaleX(0.1) scaleY(3) skewX(20deg) translateZ(0);
            filter: blur(25px);
            will-change: transform, opacity, filter;
        }

        #textContainer.effect-elastic.visible {
            opacity: 1 !important;
            transform: scaleX(1) scaleY(1) skewX(0deg) translateZ(0) !important;
            filter: blur(0px) !important;
            transition-timing-function: cubic-bezier(0.68, -0.6, 0.32, 1.6) !important;
        }

        /* ========================================  
           ANIMACI√ìN 9: GRAVITY DROP (Ca√≠da con F√≠sica)
           Entrada desde arriba con rebote realista
           ======================================== */
        #textContainer.effect-zoom-rotate {
            opacity: 0;
            transform: translateY(-400px) rotate(25deg) scale(0.5) translateZ(0);
            filter: blur(8px);
            will-change: transform, opacity, filter;
        }

        #textContainer.effect-zoom-rotate.visible {
            opacity: 1 !important;
            transform: translateY(0) rotate(0deg) scale(1) translateZ(0) !important;
            filter: blur(0px) !important;
            transition-timing-function: cubic-bezier(0.175, 0.885, 0.32, 1.275) !important;
        }

        /* ========================================  
           ANIMACI√ìN 10: NONE (Sin animaci√≥n)
           ======================================== */
        #textContainer.effect-none {
            opacity: 0;
        }

        /* Estado Visible Global (Fallback) */
        #textContainer.visible {
            opacity: 1 !important;
            transform: scale(1) translateY(0) translateZ(0) !important;
        }

        /* TICKER / MARQUESINA */
        #tickerBar {
            position: relative;
            left: 0;
            width: 100%;
            height: 40px;
            background: #000000;
            color: white;
            font-family: 'Roboto', sans-serif;
            font-weight: 700;
            font-size: 22px;
            display: none;
            align-items: center;
            overflow: hidden;
            z-index: 9998;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.8);
            flex-shrink: 0;
        }

        #tickerContent {
            display: inline-block;
            white-space: nowrap;
            padding-left: 100%;
            animation: scrollTicker linear infinite;
            line-height: 1;
            /* Prevent clipping for large fonts */
        }

        @keyframes scrollTicker {
            0% {
                transform: translateX(0);
            }

            100% {
                transform: translateX(-100%);
            }
        }

        @keyframes slideInFromTop {
            from {
                transform: translateY(-100%);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        @keyframes slideInFromBottom {
            from {
                transform: translateY(100%);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        @keyframes slideOutToTop {
            from {
                transform: translateY(0);
                opacity: 1;
            }

            to {
                transform: translateY(-100%);
                opacity: 0;
            }
        }

        @keyframes slideOutToBottom {
            from {
                transform: translateY(0);
                opacity: 1;
            }

            to {
                transform: translateY(100%);
                opacity: 0;
            }
        }
    </style>
</head>

<body>

    <div id="bgLayer"></div>
    <video id="bgVideo" loop playsinline
        style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: -1; opacity: 0; transition: opacity 1s ease; transform: scale(1.05);"></video>

    <div id="dimLayer"
        style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, var(--bg-dim)); transition: background-color 0.3s ease; z-index: -1;">
    </div>

    <div id="mainViewport">
        <!-- El ticker se mover√° aqu√≠ arriba si es .top -->
        <div id="tickerBar" class="bottom">
            <div id="tickerContent"></div>
        </div>

        <div id="contentArea">
            <!-- Presentaciones se mueven aqu√≠ para que tambi√©n eviten el ticker -->
            <img id="presentationImageA"
                src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"
                onerror="this.src='data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'"
                style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: contain; z-index: 10; opacity: 0; transition: opacity 0.5s ease, transform 0.5s ease; display: none;">
            <img id="presentationImageB"
                src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"
                onerror="this.src='data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'"
                style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: contain; z-index: 11; opacity: 0; transition: opacity 0.5s ease, transform 0.5s ease; display: none;">

            <div id="textContainer" class="effect-fade">
                <div id="textContent">
                    <!-- El texto se inyectar√° aqu√≠ -->
                </div>
                <!-- Las etiquetas de t√≠tulo y autor han sido eliminadas para una proyecci√≥n limpia -->
            </div>
        </div>
    </div>

    <!-- DEBUG CONSOLE (Temporary) -->
    <div id="debugConsole"
        style="position:fixed; bottom:10px; left:10px; background:rgba(0,0,0,0.8); color:#0f0; font-family:monospace; font-size:10px; padding:10px; border-radius:4px; z-index:99999; max-width:400px; max-height:200px; overflow:auto; pointer-events:none; display:none; border: 1px solid #0f0;">
        DEBUG MODE ON
    </div>

    <!-- BANNER DE PERMISO DE AUDIO -->
    <div id="audioPermissionBanner" onclick="this.style.display='none'"
        style="position:fixed; top:20px; left:50%; transform:translateX(-50%); background:rgba(255,165,0,0.9); color:#000; padding:10px 20px; border-radius:8px; font-weight:bold; font-family:sans-serif; cursor:pointer; z-index:10000; display:none; box-shadow:0 10px 30px rgba(0,0,0,0.5);">
        [!] SONIDO BLOQUEADO POR EL NAVEGADOR: HAGA CLIC AQU√ç PARA ACTIVAR
    </div>

    <!-- Script para detectar clic inicial -->
    <script>
        document.addEventListener('click', () => {
            const banner = document.getElementById('audioPermissionBanner');
            if (banner) banner.style.display = 'none';
            // Esto despierta el audio en el navegador
            const v = document.getElementById('bgVideo');
            if (v) { v.muted = v.muted; }
        }, { once: false });
    </script>

    <script src="js/media_db.js"></script> <!-- Base de Datos Compartida -->

    <!-- Script de configuraci√≥n OBS -->
    <script>
        // Si la URL tiene ?obs=true, hacemos el fondo transparente
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.get('obs') === 'true') {
            document.body.style.backgroundColor = 'transparent';
            console.log("Modo OBS: Fondo Transparente Activado [OBS]");
        }
    </script>

    <!-- TEMPORIZADOR FLOTANTE -->
    <div id="timerDisplay"
        style="position:fixed; top:30px; right:40px; background:rgba(0,0,0,0.6); padding:10px 20px; border-radius:12px; backdrop-filter:blur(10px); color:white; font-family:'Courier New', monospace; font-weight:bold; font-size:48px; z-index:9999; display:none; border:1px solid rgba(255,255,255,0.3); box-shadow: 0 4px 15px rgba(0,0,0,0.5);">
        00:00:00
    </div>




    <!-- L√≥gica del Visor -->
    <script>
        // Carga Din√°mica de Socket.IO solo si es Web (HTTP/HTTPS)
        if (window.location.protocol.startsWith('http')) {
            const script = document.createElement('script');
            script.src = "/socket.io/socket.io.js";
            script.onload = () => {
                console.log("Librer√≠a de Red cargada.");
                initNetwork(); // Iniciar listener de red
            };
            document.head.appendChild(script);
        }

        let overlaySocket = null;

        // Leer room ID de la URL (?room=XXXX o /v/XXXX) y normalizar a may√∫sculas


        function initNetwork() {
            if (typeof io !== 'undefined') {
                // OPTIMIZACI√ìN: Si estamos en modo LOCAL (abiertos por el panel o via file://)
                // No necesitamos Socket.io, el BroadcastChannel es suficiente.
                const isLocalPopup = window.opener !== null;
                const isFileProtocol = window.location.protocol === 'file:';

                if (isLocalPopup || isFileProtocol) {
                    console.log("üöÄ MODO LOCAL DETECTADO: Usando √∫nicamente BroadcastChannel (Red omitida)");
                    return;
                }

                console.log("Iniciando conexi√≥n de Red...");
                overlaySocket = io({
                    reconnection: true,
                    reconnectionDelay: 1000,
                    reconnectionDelayMax: 5000,
                    reconnectionAttempts: Infinity,
                    timeout: 20000
                });

                overlaySocket.on('connect', () => {
                    console.log("Conectado a Red!");
                    // En modo LOCAL (sin salas), todos son GLOBAL
                    overlaySocket.emit('join_room', { roomCode: 'GLOBAL' });

                    // Ocultar panel de sala (ya no se usa)
                    const roomPanel = document.getElementById('roomPanel');
                    if (roomPanel) roomPanel.style.display = 'none';
                });

                // REFUERZO: Asegurar re-uni√≥n autom√°tica tras micro-cortes
                overlaySocket.on('reconnect', (attempt) => {
                    console.log(`üîÑ Reconectado (Intento ${attempt}). Sincronizando global...`);
                    overlaySocket.emit('join_room', { roomCode: 'GLOBAL' });
                });

                // (isSilent es global)

                overlaySocket.on('reconnect_attempt', (attempt) => {
                    console.log(`üì° Intentando reconectar visor (#${attempt})...`);
                    if (!isSilent) showText('Reconectando...');
                });

                overlaySocket.on('network_update', (data) => {
                    // Procesar usando sistema de deduplicaci√≥n
                    processMessage(data, '[SOCKET]');
                });

                overlaySocket.on('disconnect', () => {
                    console.log("‚ùå Overlay desconectado de la red");
                    if (!isSilent) showText('Desconectado');
                });

                overlaySocket.on('room_joined', (data) => {
                    console.log(`‚úÖ [VISOR] Sincronizaci√≥n Global: ${data.roomCode}`);

                    // Al entrar, pedir estado INMEDIATAMENTE
                    overlaySocket.emit('remote_action', {
                        type: 'viewer_status',
                        action: 'joined',
                        room: data.roomCode
                    });

                    // Mostrar "Esperando..." al conectarse (si no est√° en modo silencioso)
                    if (!isSilent) {
                        console.log('üì∫ Mostrando mensaje: Esperando...');
                        // Usar setTimeout para asegurar que el DOM est√© listo
                        setTimeout(() => {
                            const textContent = document.getElementById('textContent');
                            const textContainer = document.getElementById('textContainer');
                            if (textContent && textContainer) {
                                textContent.textContent = 'Esperando...';
                                textContainer.classList.add('visible');
                                isShowingWaitingMessage = true; // Activar bandera
                                console.log('‚úÖ Mensaje "Esperando..." mostrado');
                            } else {
                                console.error('‚ùå No se encontraron elementos textContent o textContainer');
                            }
                        }, 100);
                    }
                });
            }
        }

        // Funci√≥n para conectar overlay a room
        function connectOverlayToRoom() {
            const input = document.getElementById('overlayRoomInput');
            const statusDiv = document.getElementById('overlayRoomStatus');

            const roomCode = input.value.trim().toUpperCase();

            if (!roomCode) {
                statusDiv.textContent = '[X] Ingresa c√≥digo';
                statusDiv.style.color = '#ef4444';
                return;
            }

            localStorage.setItem('zion_room_code', roomCode);

            if (overlaySocket && overlaySocket.connected) {
                overlaySocket.emit('join_room', { roomCode });
                statusDiv.textContent = `‚è≥ Conectando...`;
                statusDiv.style.color = '#f59e0b';
                console.log(`[LOCK] Overlay uni√©ndose a sala: ${roomCode}`);
            } else {
                statusDiv.textContent = '[X] No conectado';
                statusDiv.style.color = '#ef4444';
            }

            input.value = roomCode;
        }
    </script>
    <script>
        const container = document.getElementById('textContainer'); // Restaurado nombre original
        const content = document.getElementById('textContent');
        const titleElement = document.getElementById('titleElement');
        const authorElement = document.getElementById('authorElement');
        const bgLayer = document.getElementById('bgLayer');
        const bgVideo = document.getElementById('bgVideo');
        const dimLayer = document.getElementById('dimLayer'); // Added dimLayer

        // P√≠xel transparente para evitar iconos de "imagen rota"
        const TRANSPARENT_PIXEL = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';

        // VERSION STAMP PARA DEBUG
        console.log("üíé ZION VISOR v4.0 ACTIVE");

        const roomCode = 'GLOBAL';
        // Modo Silencioso Global (oculta mensajes de estado como "Conectado", "Esperando", etc.)
        const overlayUrlParams = new URLSearchParams(window.location.search);
        const isSilent = overlayUrlParams.get('silent') === 'true';
        const isNetworkVisor = true; // Forzamos true para que el sistema de estados funcione en modo local
        let isPanelConnected = false;

        // Configurar Canal Local (Prioridad para Instalador)
        const bc = new BroadcastChannel('zion-presenter-local');
        // Canal legado por compatibilidad
        const bcLegacy = new BroadcastChannel('zion-presenter');

        console.log(`üì° Overlay conectado a canal local: zion-presenter-local`);

        const handleMsg = (event) => processMessage(event.data);
        bc.onmessage = handleMsg;
        bcLegacy.onmessage = handleMsg;

        // EMERGENCY LISTENER (Solo para saltos - bypassing processMessage logic si falla)
        bc.addEventListener('message', (event) => {
            if (event.data && event.data.type === 'app_jump') {
                console.warn('üö® EMERGENCY JUMP TRIGGERED', event.data);
                const target = event.data.targetUrl || (event.data.payload && event.data.payload.url);

                // Notificaci√≥n visual temporal para debug
                const debugToast = document.createElement('div');
                debugToast.style.cssText = 'position:fixed;top:20px;left:50%;transform:translateX(-50%);background:rgba(255,0,0,0.8);color:white;padding:15px 30px;border-radius:10px;z-index:999999;font-family:sans-serif;font-weight:bold;';
                debugToast.textContent = 'üöÄ SALTO RECIBIDO: ' + target;
                document.body.appendChild(debugToast);
                setTimeout(() => debugToast.remove(), 3000);

                if (target) launchZionCastTransition(target);
            }
        });

        const recentMessages = new Set(); // Para detectar duplicados

        // Solicitar sincronizaci√≥n inicial al cargar (Local + Red)
        setTimeout(() => {
            const msg = { type: 'viewer_status', action: 'joined', roomCode: 'GLOBAL' };
            if (bc) bc.postMessage(msg);
            if (overlaySocket && overlaySocket.connected) overlaySocket.emit('remote_action', msg);
        }, 800);

        // Funci√≥n para deduplicar mensajes
        function processMessage(data, source) {
            if (!data) return;

            // EXCEPCIONES: Comandos que SIEMPRE pasan (latidos y salto de visor)
            if (data.type === 'heartbeat' || data.type === 'app_jump') {
                if (data.type === 'heartbeat') console.log(`üíì ${source} Heartbeat recibido`);
                handleMessage(data);
                return;
            }

            // En modo LOCAL (sin salas), aceptamos todos los mensajes
            // (La deduplicaci√≥n se encarga de evitar repeticiones)

            // Crear ID √∫nico del mensaje (Deduplicaci√≥n inteligente)
            // Aumentamos el l√≠mite a 2000 para distinguir entre diapositivas pesadas/PDFs
            let msgId = `${data.type}_${data.action || ''}_${data.payload ? JSON.stringify(data.payload).substring(0, 2000) : ''}`;

            // Solo a√±adir estampa de tiempo a comandos de r√°faga (brillo, navegaci√≥n sincronizada, timers)
            // Los estados (bg, slide) NO llevan tiempo para que el sync los detecte como duplicados y no parpadeen.
            if (data.type === 'remote_cmd' || data.type === 'nav' || data.type === 'timer' ||
                (data.type === 'config' && data.payload && data.payload.bgDim !== undefined)) {
                msgId += `_${Math.floor(Date.now() / 150)}`;
            }

            // Si ya procesamos este mensaje recientemente, ignorar (crucial para evitar parpadeos en sync)
            if (recentMessages.has(msgId)) {
                return;
            }

            // Agregar a la lista de recientes (400ms es el equilibrio ideal entre velocidad y protecci√≥n)
            recentMessages.add(msgId);
            setTimeout(() => recentMessages.delete(msgId), 400);

            // Procesar el mensaje
            console.log(`[OK] ${source} received:`, data.type);
            handleMessage(data);
        }

        console.log('[OK] Sistema h√≠brido inicializado - Escuchando ambos canales');

        // Configuraci√≥n actual
        let currentConfig = {
            transitionEffect: 'zoom',
            maxFontSize: 300 // Valor por defecto
        };

        // Flag para saber si ya recibimos configuraci√≥n del panel
        let configReady = false;
        let pendingContent = null; // Cola para contenido que llega antes de config
        let heartbeatTimeout = null; // Variable global para heartbeat
        let isShowingWaitingMessage = false; // Bandera para rastrear "Esperando..."

        const debugConsole = document.getElementById('debugConsole');
        function log(msg) {
            console.log(msg);
            if (debugConsole) {
                // debugConsole.style.display = 'block'; // MODO DEBUG DESACTIVADO
                const line = document.createElement('div');
                line.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
                debugConsole.insertBefore(line, debugConsole.firstChild);
            }
        }

        function handleMessage(data) {
            if (!data) return;
            log(`MSG: ${data.type} ${data.action || ''}`);
            const { type, payload, action } = data;

            switch (type) {
                case 'heartbeat':
                    // Si recibimos latido, el panel est√° vivo
                    if (heartbeatTimeout) clearTimeout(heartbeatTimeout);

                    // Marcar como conectado
                    const wasDisconnected = !isPanelConnected;
                    if (!isPanelConnected) {
                        isPanelConnected = true;
                    }

                    // Si estamos mostrando "Esperando..." o "Desconectado", cambiarlo a "Conectado"
                    const currentText = (content.textContent || "").trim();
                    if (isNetworkVisor && !isSilent && (isShowingWaitingMessage || wasDisconnected || currentText === "Desconectado")) {
                        console.log(`‚úÖ Panel detectado - Cambiando "${currentText}" a "Conectado"`);
                        content.textContent = 'Conectado';
                        container.classList.add('visible');
                        isShowingWaitingMessage = false; // Desactivar bandera
                        // NO auto-ocultar - se quedar√° hasta que llegue contenido real
                    }

                    // Reiniciar cuenta regresiva (3 segs sin latido = desconexi√≥n)
                    heartbeatTimeout = setTimeout(() => {
                        console.log("üíî Heartbeat perdido - Panel inactivo");
                        isPanelConnected = false;

                        // SIEMPRE mostrar "Desconectado" para alertar problemas
                        if (isNetworkVisor && !isSilent) {
                            console.log('‚ùå Mostrando "Desconectado"');
                            content.textContent = 'Desconectado';
                            container.classList.add('visible');
                        }
                    }, 3000); // Reducido de 5000 a 3000ms
                    break;
                case 'config':
                    applyConfig(payload);
                    configReady = true; // Marcar que ya tenemos config

                    // Si hab√≠a contenido pendiente, procesarlo ahora
                    if (pendingContent) {
                        log('‚è≠Ô∏è Procesando contenido pendiente despu√©s de recibir config');
                        setTimeout(() => {
                            handleMessage(pendingContent);
                            pendingContent = null;
                        }, 50); // Micro delay para asegurar que config se aplic√≥ completamente
                    }
                    break;
                case 'slide':
                    // Si no tenemos config todav√≠a, esperar activamente hasta 500ms
                    if (!configReady) {
                        log('‚è∏Ô∏è Config no lista, esperando...');
                        let waitTime = 0;
                        const checkInterval = setInterval(() => {
                            waitTime += 50;
                            if (configReady) {
                                clearInterval(checkInterval);
                                log('‚úÖ Config recibida, procesando slide');
                                showSlide(payload);
                            } else if (waitTime >= 500) {
                                clearInterval(checkInterval);
                                log('‚ö†Ô∏è Timeout esperando config, usando defaults');
                                showSlide(payload);
                            }
                        }, 50);
                        return;
                    }
                    showSlide(payload);
                    break;
                case 'text':
                    // Si no tenemos config todav√≠a, esperar activamente hasta 500ms
                    if (!configReady) {
                        log('‚è∏Ô∏è Config no lista, esperando...');
                        let waitTime = 0;
                        const checkInterval = setInterval(() => {
                            waitTime += 50;
                            if (configReady) {
                                clearInterval(checkInterval);
                                log('‚úÖ Config recibida, procesando texto');
                                showText(payload.text);
                            } else if (waitTime >= 500) {
                                clearInterval(checkInterval);
                                log('‚ö†Ô∏è Timeout esperando config, usando defaults');
                                showText(payload.text);
                            }
                        }, 50);
                        return;
                    }
                    showText(payload.text);
                    break;
                case 'bg':
                    if (action === 'update') {
                        // Detecci√≥n de fondo id√©ntico para evitar parpadeo en sincronizaci√≥n
                        // Incluimos isContent para distinguir entre fondo de sistema y diapositiva de imagen
                        const bgHash = `${payload.image}_${payload.mediaType}_${payload.sourceMode}_${payload.isContent || false}_${payload.fitMode || 'cover'}`;
                        const currentOpacity = parseFloat(bgLayer.style.opacity) || parseFloat(bgVideo.style.opacity) || 0;

                        if (bgLayer.dataset.lastBgHash === bgHash && currentOpacity > 0.1) {
                            console.log("‚è≠Ô∏è Sync: Fondo id√©ntico ya activo. Omitiendo animaci√≥n.");
                            return;
                        }
                        bgLayer.dataset.lastBgHash = bgHash;

                        setBackground(payload.image, payload.mediaType, payload.loop, payload.sourceMode, payload.muted, payload.fitMode, payload.isContent);

                        // PERSISTENCIA REACTIVADA
                        if (!payload.isContent && payload.sourceMode !== 'db') {
                            localStorage.setItem('bosquejos_bg', payload.image);
                            localStorage.setItem('bosquejos_bg_type', payload.mediaType || 'image');
                            localStorage.setItem('bosquejos_bg_source', payload.sourceMode || 'url');
                            log(`‚úÖ Fondo persistido en localStorage del visor: ${payload.image}`);
                        }
                    }
                    if (action === 'clear') {
                        clearBackground();
                        // LIMPIAR TAMBI√âN DE MEMORIA
                        localStorage.removeItem('bosquejos_bg');
                        localStorage.removeItem('bosquejos_bg_type');
                        localStorage.removeItem('bosquejos_bg_source');
                    }
                    if (action === 'pause') bgVideo.pause();
                    if (action === 'play') bgVideo.play().catch(e => log("Play Error: " + e.message));
                    if (action === 'update_setting') {
                        if (payload.loop !== undefined) bgVideo.loop = payload.loop;
                        if (payload.muted !== undefined) bgVideo.muted = payload.muted;
                        if (payload.fitMode !== undefined) {
                            bgVideo.style.objectFit = payload.fitMode;
                            bgLayer.style.backgroundSize = (payload.fitMode === 'fill' ? '100% 100%' : payload.fitMode);
                        }
                    }
                    break;
                case 'nav':
                    if (action === 'blackout') hideText();
                    break;
                case 'timer':
                    updateTimerOverlay(payload, action);
                    break;
                case 'ticker':
                    updateTicker(payload, action);
                    break;
                case 'panel_status':
                    if (action === 'ready') {
                        // Panel activo detectado
                        console.log('üì° Panel activo detectado');
                        const isVisible = container.classList.contains('visible');
                        const hasBackground = bgLayer.style.opacity == "1" || bgVideo.style.opacity == "1";

                        // Solo mostrar "Conectado" si:
                        // 1. Es el Visor de RED (No el local)
                        // 2. NO es una reconexi√≥n silenciosa (ya estaba marcado como conectado)
                        // 3. La pantalla est√° TOTALMENTE VAC√çA (sin texto ni fondo)
                        if (isNetworkVisor && !isPanelConnected && !isSilent && !isVisible && !hasBackground) {
                            showText('Conectado');
                        }

                        isPanelConnected = true;
                    } else if (action === 'disconnected') {
                        console.log('üì¥ Panel desconectado');
                        isPanelConnected = false;
                        const isVisible = container.classList.contains('visible');
                        const hasBackground = bgLayer.style.opacity == "1" || bgVideo.style.opacity == "1";

                        // Solo mostrar "Desconectado" en red y si la pantalla est√° vac√≠a
                        if (isNetworkVisor && !isSilent && !isVisible && !hasBackground) {
                            showText('Desconectado');
                        }
                    }
                    break;
                case 'presentation':
                    // Nuevo: Manejo dedicado para presentaciones
                    showPresentation(payload.image, payload.fitMode || 'contain');
                    break;
                case 'app_jump':
                    // Soporte para payload.url o root targetUrl
                    const targetUrl = (payload && payload.url) ? payload.url : data.targetUrl;
                    console.log('üöÄ [JUMP COMMAND RECEIVED]', targetUrl);

                    if (targetUrl) {
                        launchZionCastTransition(targetUrl);
                    }
                    break;
            }
        }

        // (Listener legado eliminado: El listener principal est√° arriba usando processMessage)

        function updateTimerOverlay(payload, action) {
            const clock = document.getElementById('timerDisplay');
            if (!clock) return;

            if (payload.visible === false) {
                clock.style.display = 'none';
                return;
            }

            // Actualizar texto
            if (clock.innerText !== payload.text) {
                clock.innerText = payload.text || "00:00:00";
            }

            // L√ìGICA DE OSCURIDAD DEL GLOBO:
            // El slider de opacidad (0 a 1) controla el canal ALFA del fondo negro.
            const bgAlpha = (payload.opacity !== undefined) ? payload.opacity : 0.6;

            // Estilos base compartidos
            const baseStyles = {
                position: 'fixed',
                zIndex: '9999',
                fontFamily: "'Courier New', monospace",
                fontWeight: 'bold',
                color: 'white',
                opacity: '1', // Los n√∫meros siempre visibles
                backdropFilter: bgAlpha > 0 ? 'blur(10px)' : 'none',
                WebkitBackdropFilter: bgAlpha > 0 ? 'blur(10px)' : 'none',
                borderRadius: payload.centered ? '50px' : '15px',
                // Aplicamos la opacidad del slider SOLO al fondo
                backgroundColor: `rgba(0, 0, 0, ${bgAlpha})`,
                boxShadow: bgAlpha > 0 ? `0 10px 40px rgba(0,0,0,${bgAlpha * 0.8})` : 'none',
                border: `1px solid rgba(255,255,255,${bgAlpha * 0.3})`,
                display: 'block',
                textAlign: 'center',
                transition: 'all 0.1s ease'
            };

            // Diferenciar entre modo CENTRADO (Gigante) y FLOTANTE
            if (payload.centered) {
                Object.assign(clock.style, baseStyles, {
                    top: '50%',
                    left: '50%',
                    right: 'auto',
                    bottom: 'auto',
                    transform: 'translate(-50%, -50%)',
                    fontSize: 'clamp(100px, 25vw, 450px)', // ¬°M√°s grande!
                    padding: '3% 6%',
                    width: '90vw',
                    maxWidth: 'fit-content'
                });
            } else {
                Object.assign(clock.style, baseStyles, {
                    top: '50%',
                    right: '50%',
                    left: 'auto',
                    bottom: 'auto',
                    transform: `translate(50%, -50%) translate(${payload.posX || 0}px, ${payload.posY || 0}px)`,
                    fontSize: (payload.fontSize || 48) + 'px',
                    padding: '12px 28px',
                    width: 'auto',
                    minWidth: '220px'
                });
            }
        }

        function updateTicker(payload, action) {
            const tickerBar = document.getElementById('tickerBar');
            const tickerContent = document.getElementById('tickerContent');

            console.log('üì∫ Overlay recibi√≥:', payload);

            if (!tickerBar || !tickerContent) return;

            // Ocultar con animaci√≥n
            if (payload.enabled === false) {
                const currentPosition = tickerBar.className || 'bottom';
                const slideOutAnim = currentPosition === 'top' ? 'slideOutToTop' : 'slideOutToBottom';

                tickerBar.style.animation = `${slideOutAnim} 0.4s ease-out forwards`;
                setTimeout(() => {
                    tickerBar.style.display = 'none';
                    tickerBar.style.animation = '';
                    fitText();
                }, 400);
                return;
            }

            // Actualizar texto
            if (payload.text !== undefined) {
                tickerContent.innerText = payload.text;
            }

            // Actualizar TAMA√ëO sin reiniciar animaci√≥n
            if (payload.size !== undefined) {
                const sizeMap = {
                    1: { height: '30px', fontSize: '16px' },
                    2: { height: '40px', fontSize: '22px' },
                    3: { height: '60px', fontSize: '32px' },
                    4: { height: '80px', fontSize: '44px' },
                    5: { height: '100px', fontSize: '56px' },
                    6: { height: '130px', fontSize: '72px' },
                    7: { height: '160px', fontSize: '96px' },
                    8: { height: '200px', fontSize: '120px' }
                };

                const size = sizeMap[payload.size] || sizeMap[3];
                tickerBar.style.height = size.height;
                tickerBar.style.minHeight = size.height; // Extra safety for flex
                tickerContent.style.fontSize = size.fontSize;
                tickerContent.style.lineHeight = size.height; // Center text vertically

                // Ajustar texto si el tama√±o del ticker cambi√≥ (cambia espacio disponible)
                setTimeout(fitText, 100);
            }

            // Actualizar velocidad - SOLO AQU√ç reiniciamos animaci√≥n
            if (payload.speed !== undefined) {
                const duration = 30 - (payload.speed * 2); // 28s (lento) a 10s (r√°pido)

                // Reiniciar animaci√≥n SOLO al cambiar velocidad
                tickerContent.style.animation = 'none';
                void tickerContent.offsetWidth; // Trigger reflow
                tickerContent.style.animation = `scrollTicker ${duration}s linear infinite`;
            }

            // Actualizar posici√≥n
            const newPosition = payload.position || 'bottom';
            if (payload.position) {
                tickerBar.className = newPosition;
                tickerBar.style.order = (newPosition === 'top' ? '-1' : '1');
            }

            // Mostrar ticker con animaci√≥n de entrada
            if (tickerBar.style.display === 'none' || !tickerBar.style.display) {
                tickerBar.style.display = 'flex';
                tickerBar.style.alignItems = 'center';

                const slideInAnim = newPosition === 'top' ? 'slideInFromTop' : 'slideInFromBottom';
                tickerBar.style.animation = `${slideInAnim} 0.5s ease-out forwards`;
                setTimeout(fitText, 500);
            }
        }



        function applyConfig(newConfig) {
            if (!newConfig) return;

            // Fusi√≥n at√≥mica de configuraci√≥n
            currentConfig = { ...currentConfig, ...newConfig };

            // GUARDAR en localStorage para persistencia entre recargas
            localStorage.setItem('bosquejos_config', JSON.stringify(currentConfig));

            const root = document.documentElement.style;
            root.setProperty('--font-family', currentConfig.fontFamily || 'system-ui');
            root.setProperty('--text-transform', currentConfig.uppercase ? 'uppercase' : 'none');
            root.setProperty('--text-shadow', (currentConfig.textShadow || 0));
            root.setProperty('--text-color', currentConfig.textColor || '#ffffff');
            root.setProperty('--shadow-color', currentConfig.shadowColor || '#000000');
            root.setProperty('--font-weight', currentConfig.boldText ? '800' : '400');

            // Seguridad en m√°rgenes (Corregido: permitir 0)
            const mY = (currentConfig.marginSize !== undefined) ? currentConfig.marginSize : 50;
            const mX = (currentConfig.marginSizeX !== undefined) ? currentConfig.marginSizeX : 80;

            root.setProperty('--margin', mY + 'px');
            root.setProperty('--margin-x', mX + 'px');
            root.setProperty('--line-height', currentConfig.lineHeight || 0.95);

            root.setProperty('--bg-dim', (currentConfig.bgDim || 0) / 100);
            root.setProperty('--bg-blur', (currentConfig.bgBlur || 0) + 'px');
            root.setProperty('--transition-duration', (currentConfig.transitionDuration || 1.0) + 's');

            // Sincronizar efectos (Solo si el efecto cambi√≥ para evitar parpadeo)
            const effectClass = `effect-${currentConfig.transitionEffect || 'fade'}`;
            if (!container.classList.contains(effectClass)) {
                const isVisible = container.classList.contains('visible');
                container.className = effectClass + (isVisible ? ' visible' : '');
            }

            if (content.innerText.trim()) fitText();
        }

        function showSlide(data) {
            // DETECTAR CONTENIDO ID√âNTICO para evitar re-animar innecesariamente (Sync silencioso)
            const contentHash = JSON.stringify({
                l: data.lines,
                t: data.title,
                a: data.author,
                b: !!data.isBible,
                an: !!data.isAnnouncement
            });

            if (content.dataset.lastHash === contentHash && container.classList.contains('visible')) {
                console.log("‚è≠Ô∏è Sincronizaci√≥n silenciosa: Contenido id√©ntico, omitiendo animaci√≥n.");
                return;
            }
            content.dataset.lastHash = contentHash;

            // 0. Ocultar presentaci√≥n si est√° visible
            hidePresentation();

            // 1. Determinar si necesitamos fade-out previo
            const isAlreadyVisible = container.classList.contains('visible');
            const transitionMs = (currentConfig.transitionDuration || 1.0) * 1000;

            if (isAlreadyVisible) {
                // Si ya es visible, primero ocultamos
                container.classList.remove('visible');

                // Esperamos a que se desvanezca casi por completo (80% del tiempo)
                setTimeout(() => {
                    updateSlideContent(data);
                }, transitionMs * 0.8);
            } else {
                // Si estaba oculto (Blackout), actualizamos e iniciamos fade-in sin esperas innecesarias
                updateSlideContent(data);
            }
        }

        // Nueva funci√≥n auxiliar para centralizar la actualizaci√≥n
        function updateSlideContent(data) {
            // 2. Configurar Contenido
            let mainText = "";
            if (data.lines && data.lines.length > 0) {
                mainText = data.lines[0]; // Por ahora solo primera l√≠nea/verso
            }

            // Configuraci√≥n de contenido finalizada

            if (data.isBible) {
                // MODO BIBLIA DUAL / SINGLE
                content.style.paddingLeft = "0";
                content.style.paddingRight = "0";
                content.style.whiteSpace = "normal";

                let bibleHtml = "";
                const versions = data.versions || [];

                const isDual = data.lines.length > 1;

                // En modo dual, reducir padding global para maximizar espacio
                if (isDual) {
                    container.style.padding = "calc(var(--margin) * 0.5) calc(var(--margin-x) * 0.5)";
                } else {
                    container.style.padding = "var(--margin) var(--margin-x)";
                }

                data.lines.forEach((line, idx) => {
                    if (idx > 0) {
                        // DIVISOR (Solo en comparativa)
                        bibleHtml += `
                                <div style="
                                    height: 1px; 
                                    background: linear-gradient(90deg, transparent, currentColor, transparent); 
                                    opacity: 0.5; 
                                    margin: 15px auto; 
                                    width: 60%;
                                "></div>
                            `;
                    }

                    // ETIQUETA DE VERSI√ìN
                    // 1. Vers√≠culo √önico: NO mostrar etiqueta (ya est√° en el t√≠tulo).
                    // 2. Comparativa: Mostrar etiqueta FLOTANTE en esquina inferior derecha (ahorro espacio).
                    const verLabel = versions[idx] ? versions[idx].replace('bibleSource_', '') : '';
                    let labelHtml = '';

                    if (isDual && verLabel) {
                        labelHtml = `
                                <div style="
                                    position: absolute;
                                    bottom: -0.15em; 
                                    right: 0;
                                    font-size: 0.8em; 
                                    opacity: 0.9; 
                                    font-weight: 900;
                                    font-style: italic;
                                    pointer-events: none;
                                ">${verLabel}</div>
                            `;
                    }

                    bibleHtml += `
                            <div style="position: relative; width: 100%; padding-bottom: ${isDual && verLabel ? '1.2em' : '0'};">
                                <div>${line}</div>
                                ${labelHtml}
                            </div>
                        `;
                });

                const citationSize = isDual ? '0.7em' : '0.55em';
                content.innerHTML = `
                        <div style="display:flex; flex-direction:column; justify-content:center;">
                            ${bibleHtml}
                            <div style="margin-top: 0.5em; font-size: ${citationSize}; font-weight: 800; opacity: 0.9; letter-spacing: 1px; text-transform:uppercase;">${data.title}</div>
                        </div>
                    `;
            } else if (data.isAnnouncement) {
                // MODO ANUNCIO P√öBLICO
                container.style.padding = "var(--margin) var(--margin-x)"; // Restaurar padding normal
                content.style.paddingLeft = "0";
                content.style.paddingRight = "0";
                content.style.whiteSpace = "pre-wrap";
                content.style.wordBreak = "normal"; // No romper palabras a medias
                content.style.overflowWrap = "break-word"; // Romper solo si es necesario

                // UNIR TODAS LAS L√çNEAS con saltos de l√≠nea
                const fullText = data.lines.join('<br>');

                // Solo el cuerpo del mensaje, IGNORANDO EL T√çTULO
                content.innerHTML = `<div style="font-weight: 500;">${fullText}</div>`;

                // Limpieza de estados finalizada
            } else {
                // Resetear estilos para cantos
                container.style.padding = "var(--margin) var(--margin-x)"; // Restaurar padding normal
                content.style.paddingLeft = "0";
                content.style.paddingRight = "0";
                content.style.whiteSpace = "pre-wrap"; // Restaurar para cantos

                // MODO CANTO: Reemplazar saltos de l√≠nea por <br> expl√≠citos
                // MODO CANTO: Usamos innerText para que el CSS maneje los saltos de l√≠nea
                content.innerText = mainText;

                // Aplicar contenido al visor
            }

            // 3. FORZAR C√ÅLCULO INMEDIATO del fontSize ANTES de animar
            void container.offsetWidth; // Forzar un reflow
            fitText(); // Calcular tama√±o √≥ptimo
            void content.offsetWidth; // Aplicar cambio

            // 4. AHORA S√ç iniciar animaci√≥n con el tama√±o correcto
            requestAnimationFrame(() => {
                container.classList.add('visible');
            });
        }

        function showText(text) {
            showSlide({ lines: [text], title: "", author: "" });
        }

        // Variable para alternar entre A y B
        let currentPresImage = 'A';

        function showPresentation(imageData, fitMode = 'contain') {
            // SI LA IMAGEN EST√Å VAC√çA: Simplemente ocultar y salir
            if (!imageData) {
                hidePresentation();
                return;
            }

            const imgA = document.getElementById('presentationImageA');
            const imgB = document.getElementById('presentationImageB');
            const textContainer = document.getElementById('textContainer');

            if (!imgA || !imgB) return;

            // Determinar cu√°l imagen usar (alternar)
            const activeImg = currentPresImage === 'A' ? imgA : imgB;
            const inactiveImg = currentPresImage === 'A' ? imgB : imgA;

            // DETECTAR SI ES LA MISMA IMAGEN YA ACTIVA (Para evitar re-animar en sync)
            const isAlreadyShowing = activeImg.src === imageData || activeImg.dataset.lastSrc === imageData;

            if (isAlreadyShowing && activeImg.style.opacity == "1") {
                console.log("‚è≠Ô∏è Sync: Diapositiva id√©ntica ya activa. Omitiendo animaci√≥n.");
                // Asegurar que el modo de ajuste sea el correcto por si cambi√≥
                activeImg.style.objectFit = fitMode;
                return;
            }

            // Guardar referencia para futura comparaci√≥n
            if (currentPresImage === 'A') imgB.dataset.lastSrc = imageData;
            else imgA.dataset.lastSrc = imageData;

            // Ocultar texto
            if (textContainer) textContainer.classList.remove('visible');

            // Configurar la nueva imagen (la que va a aparecer)
            inactiveImg.src = imageData;
            inactiveImg.style.objectFit = fitMode;
            inactiveImg.style.display = 'block';
            inactiveImg.style.transform = 'scale(1.05)';
            inactiveImg.style.zIndex = currentPresImage === 'A' ? '11' : '10';

            // Peque√±o delay para que el navegador registre el cambio
            setTimeout(() => {
                // Fade in de la nueva imagen con zoom
                inactiveImg.style.opacity = '1';

                // Fade out de la imagen anterior (si existe)
                if (activeImg.src) {
                    activeImg.style.transform = 'scale(0.95)';
                    activeImg.style.opacity = '0';
                }

                // Volver a escala normal
                setTimeout(() => {
                    inactiveImg.style.transform = 'scale(1)';

                    // Limpiar la imagen anterior despu√©s de la transici√≥n
                    setTimeout(() => {
                        activeImg.style.display = 'none';
                        activeImg.src = TRANSPARENT_PIXEL;
                        activeImg.style.transform = 'scale(1)';
                    }, 500);
                }, 50);

                // Alternar para la pr√≥xima vez
                currentPresImage = currentPresImage === 'A' ? 'B' : 'A';
            }, 50);

            console.log(`üìä Presentaci√≥n mostrada (${fitMode})`);
        }

        function hidePresentation() {
            const imgA = document.getElementById('presentationImageA');
            const imgB = document.getElementById('presentationImageB');

            if (imgA) {
                imgA.style.opacity = '0';
                imgA.style.transform = 'scale(0.95)';
                // Cambiar el src INMEDIATAMENTE a transparente para que no salga el icono de error
                imgA.src = TRANSPARENT_PIXEL;
                setTimeout(() => {
                    imgA.style.display = 'none';
                    imgA.style.transform = 'scale(1)';
                }, 500);
            }

            if (imgB) {
                imgB.style.opacity = '0';
                imgB.style.transform = 'scale(0.95)';
                imgB.src = TRANSPARENT_PIXEL;
                setTimeout(() => {
                    imgB.style.display = 'none';
                    imgB.style.transform = 'scale(1)';
                }, 500);
            }

            // Resetear el estado
            currentPresImage = 'A';
        }

        let currentMediaBlobUrl = null;

        async function setBackground(data, type = 'image', loop = true, sourceMode = 'db', muted = true, fitMode = 'cover', isContent = false, instant = false) {
            // Limpiar URL anterior para liberar memoria
            if (currentMediaBlobUrl) {
                URL.revokeObjectURL(currentMediaBlobUrl);
                currentMediaBlobUrl = null;
            }

            let mediaUrl = data;

            // DETECCI√ìN DE BLOB/FILE (Optimizaci√≥n Binaria)
            if (data instanceof Blob || data instanceof File) {
                currentMediaBlobUrl = URL.createObjectURL(data);
                mediaUrl = currentMediaBlobUrl;
                log("üöÄ Binary Blob stream active");
            }
            // MODO VIDEO BASE64 (Solo Legacy o fallbacks)
            else if (type === 'video' && typeof data === 'string' && data.startsWith('data:')) {
                try {
                    const response = await fetch(data);
                    const blob = await response.blob();
                    currentMediaBlobUrl = URL.createObjectURL(blob);
                    mediaUrl = currentMediaBlobUrl;
                    log("Optimized Video: Converted Base64 to Blob URL for performance");
                } catch (e) {
                    log("Optimization Warning: Could not convert data URI to Blob. Using raw data.");
                }
            }
            // MODO BASE DE DATOS (IndexedDB)
            else if (sourceMode === 'db') {
                try {
                    let db = window.MediaDB || window.mediaDB;
                    if (db) {
                        const file = await db.getFile(data);
                        if (file) {
                            mediaUrl = URL.createObjectURL(file);
                            log("Blob URL created from DB");
                        } else {
                            log("File not found in DB");
                            if (data.includes('/') || data.includes('http')) mediaUrl = data;
                            else return;
                        }
                    } else {
                        log("MediaDB not ready");
                        if (data.includes('/') || data.includes('http')) mediaUrl = data;
                        else return;
                    }
                } catch (e) {
                    log("DB Error: " + e.message);
                    if (data.includes('/') || data.includes('http')) mediaUrl = data;
                    else return;
                }
            } else {
                // L√ìGICA ANTIGUA (URL Streaming)
                if (data && !data.startsWith('http') && !data.startsWith('blob:') && !data.startsWith('data:') && !data.startsWith('file:')) {
                    const isWeb = window.location.protocol.startsWith('http');
                    const baseUrl = isWeb ? '' : 'http://localhost:3000';
                    mediaUrl = baseUrl + '/media?path=' + encodeURIComponent(data);
                }
            }

            log(`BG Update: ${type} (In: ${instant})`);

            if (type === 'video') {
                bgLayer.style.opacity = 0;

                bgVideo.src = mediaUrl;
                bgVideo.loop = loop;
                bgVideo.muted = muted;
                bgVideo.style.objectFit = fitMode;

                if (instant) bgVideo.style.transition = 'none';

                bgVideo.load();
                const playPromise = bgVideo.play();

                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        bgVideo.style.opacity = 1;
                        if (!muted) bgVideo.muted = false;
                        if (instant) setTimeout(() => bgVideo.style.transition = '', 100);
                    }).catch(e => {
                        log("Video play error: " + e.message);
                    });
                }
                bgVideo.style.zIndex = isContent ? "0" : "-2";

            } else {
                // IMAGEN
                bgVideo.style.opacity = 0;
                bgVideo.pause();

                if (instant) bgLayer.style.transition = 'none';
                if (!instant) bgLayer.style.opacity = 0;

                const img = new Image();
                img.onload = () => {
                    bgLayer.style.backgroundImage = `url('${mediaUrl}')`;
                    bgLayer.style.backgroundSize = (fitMode === 'fill' ? '100% 100%' : fitMode);

                    if (isContent) {
                        bgLayer.style.zIndex = "0";
                        bgLayer.style.filter = "none";
                        bgLayer.style.transform = "scale(1)";
                    } else {
                        bgLayer.style.zIndex = "-3";
                        bgLayer.style.filter = "blur(var(--bg-blur))";
                        bgLayer.style.transform = "scale(1.05)";
                    }

                    if (instant) {
                        bgLayer.style.opacity = 1;
                        setTimeout(() => bgLayer.style.transition = '', 100);
                    } else {
                        requestAnimationFrame(() => bgLayer.style.opacity = 1);
                    }
                    log("Imagen cargada y mostrada");
                };
                img.onerror = () => log("Error loading image: " + mediaUrl);
                img.src = mediaUrl;
            }
        }

        function clearBackground() {
            bgLayer.style.opacity = 0;
            bgVideo.style.opacity = 0;
            setTimeout(() => {
                bgLayer.style.backgroundImage = 'none';
                bgVideo.pause();
                bgVideo.src = "";
            }, 1000);
        }

        function restoreGlobalBackground() {
            log("Restoring Clean Background (Local Storage Disabled)...");
            // Ya no restauramos de localStorage por petici√≥n del usuario
            clearBackground();
        }

        // Detectar fin de video para restaurar fondo si no hay loop
        bgVideo.addEventListener('ended', () => {
            if (!bgVideo.loop) {
                log("Video ended, restoring background...");
                restoreGlobalBackground();
            }
        });

        function hideText() {
            container.classList.remove('visible');
            hidePresentation(); // Tambi√©n ocultar presentaciones

            // Esperar la duraci√≥n completa de la animaci√≥n antes de borrar el contenido
            const duration = (currentConfig.transitionDuration || 1.0) * 1000;

            setTimeout(() => {
                // Solo limpiar si no se ha vuelto a mostrar
                if (!container.classList.contains('visible')) {
                    content.innerHTML = "";
                    titleElement.innerText = "";
                    authorElement.innerText = "";
                }
            }, duration);
        }

        // Cach√© del √∫ltimo tama√±o calculado
        let lastTextLength = 0;
        let lastFontSize = 100;

        // Algoritmo de Auto-Ajuste (Optimizado con RAF)
        function fitText() {
            if (!content.innerText.trim()) return;

            // Si autoFit est√° desactivado, simplemente usar el tama√±o m√°ximo
            if (currentConfig.autoFit === false) {
                content.style.fontSize = (currentConfig.maxFontSize || 300) + 'px';
                return;
            }

            const textLen = content.innerText.length;

            // TODO: Cach√© desactivado temporalmente - causaba que los padding no se actualizaran
            // if (Math.abs(textLen - lastTextLength) < lastTextLength * 0.2 && lastFontSize > 0) {
            //     content.style.fontSize = lastFontSize + 'px';
            //     return;
            // }

            // Ejecutar directamente para respetar padding inmediatamente
            let min = 10;
            let max = parseInt(currentConfig.maxFontSize) || 600;
            let optimal = min;

            // DEBUG: Ver qu√© valor de maxFontSize estamos usando
            console.log(`üîç fitText() usando maxFontSize: ${max} (config:`, currentConfig.maxFontSize, ')');

            // Calcular espacio disponible REAL (Respetando valores 0)
            const style = window.getComputedStyle(container);
            const pL = parseFloat(style.paddingLeft) || 0;
            const pR = parseFloat(style.paddingRight) || 0;
            const pT = parseFloat(style.paddingTop) || 0;
            const pB = parseFloat(style.paddingBottom) || 0;

            const padX = pL + pR;
            const padY = pT + pB;

            // Dimensiones disponibles con salvaguarda de emergencia si el contenedor mide 0
            const availableWidth = Math.max(container.clientWidth - padX, 50);
            const availableHeight = Math.max(container.clientHeight - padY, 50);

            // DEBUG: Ver dimensiones disponibles
            console.log(`üìê Container: ${container.clientWidth}x${container.clientHeight}, Padding: ${padX}x${padY}, Disponible: ${availableWidth}x${availableHeight}`);

            // B√∫squeda binaria del tama√±o ideal (M√ÅXIMO 8 iteraciones)
            let iterations = 0;
            const maxIterations = 8;

            while (min <= max && iterations < maxIterations) {
                let mid = Math.floor((min + max) / 2);
                content.style.fontSize = mid + 'px';

                // Usamos offsetHeight/Width que son m√°s fiables
                const fitsWidth = content.offsetWidth <= (availableWidth + 5);
                const fitsHeight = content.offsetHeight <= (availableHeight + 5);

                if (fitsWidth && fitsHeight) {
                    optimal = mid;
                    min = mid + 1;
                } else {
                    max = mid - 1;
                }
                iterations++;
            }

            content.style.fontSize = optimal + 'px';

            // Guardar en cach√©
            lastTextLength = textLen;
            lastFontSize = optimal;
        }

        // Inicializar
        function init() {
            // Cargar Configuraci√≥n
            const savedConfig = localStorage.getItem('bosquejos_config');
            if (savedConfig) {
                applyConfig(JSON.parse(savedConfig));
                configReady = true; // Ya tenemos config del localStorage
                log('‚úÖ Config cargada desde localStorage del visor');
            } else {
                container.classList.add('effect-fade'); // Default
                // No marcar configReady aqu√≠ - esperaremos a que llegue del panel
            }

            // Cargar Fondo autom√°ticamente al arrancar (Persistencia Reactivada)
            const savedBg = localStorage.getItem('bosquejos_bg');
            const savedType = localStorage.getItem('bosquejos_bg_type') || 'image';
            const savedSource = localStorage.getItem('bosquejos_bg_source') || 'normal';

            if (savedBg) {
                console.log("Restaurando fondo guardado:", savedBg);
                setTimeout(() => {
                    // Pasar 'true' como √∫ltimo argumento para modo instant√°neo
                    setBackground(savedBg, savedType, true, savedSource, true, 'cover', false, true);
                }, 100); // Reducir delay tambi√©n para que sea m√°s r√°pido
            }
        }

        // Optimizaci√≥n para evitar lag al redimensionar
        let resizeTimer;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);

            // NO tocar el DOM aqu√≠ para m√°xima fluidez durante el arrastre
            resizeTimer = setTimeout(() => {
                log("Window resize stabilized - updating layout");
                fitText();
                // Opcional: refrescar video si es necesario
                if (bgVideo.style.opacity > 0) {
                    // Solo una peque√±a ayuda si hay video
                    bgVideo.style.willChange = 'opacity, filter';
                }
            }, 250); // 250ms es m√°s amable con el procesador
        });

        function launchZionCastTransition(url) {
            // 1. Crear Overlay Negro (Fondo de transici√≥n r√°pido)
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
                background: #000000; z-index: 2147483647;
                opacity: 0; transition: opacity 0.3s ease;
            `;

            document.body.appendChild(overlay);

            // 2. Fade In r√°pido y Navegar
            requestAnimationFrame(() => {
                overlay.style.opacity = '1';
                setTimeout(() => {
                    window.location.href = url;
                }, 150); // Tiempo m√≠nimo para ocultar contenido antes del salto
            });
        }

        // Manejar Fullscreen con Esc y Doble Clic
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (document.fullscreenElement) {
                    document.exitFullscreen();
                }
            }
        });

        document.addEventListener('dblclick', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(e => {
                    console.warn("Error al entrar en pantalla completa:", e);
                });
            } else {
                document.exitFullscreen();
            }
        });

        init();
    </script>
</body>

</html>