/**
 * ZION CAST - Overlay Logic v1.0
 * Arquitectura Limpia y Estabilidad.
 */

console.log("üíé Zion Cast Overlay Iniciado (Network Mode)");

let socket;
if (typeof io !== 'undefined') {
    socket = io();
} else {
    console.warn("‚ö†Ô∏è Socket.io not found. Using local-only mode.");
    socket = { on: () => { } }; // Mock to prevent crashes
}
const bc = new BroadcastChannel('zion_channel');

// Estado Local
const state = {
    show: { center: false, title: true, bl: true, br: true, cb: false },
    text: { center: '', title: '', bl: '', br: '', cb: '' }
};

// Mapa de Elementos
const el = {
    center: document.getElementById('unit-center'),
    title: document.getElementById('unit-title'),
    bl: document.getElementById('unit-bl'),
    br: document.getElementById('unit-br'),
    cb: document.getElementById('unit-cb'),

    txtCenter: document.getElementById('content-center'),
    txtTitle: document.getElementById('content-title'),
    txtBl: document.getElementById('content-bl'),
    txtBr: document.getElementById('content-br'),
    txtCb: document.getElementById('content-cb')
};

// --- RECEPTION ---
let isInitialized = false;

function handleAppPacket(data) {
    if (!data) return;

    // --- REVEAL UI ON FIRST PACKET ---
    if (!isInitialized) {
        setTimeout(() => {
            const app = document.getElementById('app-container');
            if (app) app.classList.add('ready');
        }, 2100);
        isInitialized = true;
    }

    const { type, payload } = data;
    if (type === 'zion:update') handleUpdate(payload);
    if (type === 'zion:style') handleStyle(payload);
    if (type === 'zion:verseStyle') handleVerseStyle(payload);
    if (type === 'theme') handleTheme(data.theme);
}

function handleTheme(themeName) {
    if (!themeName) return;
    const themes = ['theme-cosmic', 'theme-emerald', 'theme-sunset', 'theme-gold', 'theme-midnight', 'theme-azure', 'theme-flame', 'theme-electric', 'theme-neon', 'theme-lime'];
    themes.forEach(t => document.body.classList.remove(t));
    document.body.classList.add(themeName);
    console.log("üëó Overlay Theme Updated:", themeName);
}

socket.on('dispatch', handleAppPacket);
bc.onmessage = (e) => handleAppPacket(e.data);

// Handle verse balloon style updates
function handleVerseStyle(payload) {
    if (!payload) return;

    const root = document.documentElement;
    if (payload.verseW) root.style.setProperty('--verse-w', payload.verseW);
    if (payload.verseH) root.style.setProperty('--verse-h', payload.verseH);
    if (payload.verseX) root.style.setProperty('--verse-x', payload.verseX);
    if (payload.verseY) root.style.setProperty('--verse-y', payload.verseY);
    if (payload.versePad) root.style.setProperty('--verse-padding', payload.versePad);
    if (payload.verseOp) root.style.setProperty('--verse-opacity', payload.verseOp);

    // Re-fit text after style changes (with enough delay for transition/render)
    if (document.body.classList.contains('mode-verse')) {
        requestAnimationFrame(() => {
            setTimeout(() => fitVerseText(), 300);
        });
    }
}

// Load saved verse styles on init
const savedVerseStyle = localStorage.getItem('zion_verseStyle');
if (savedVerseStyle) {
    try {
        handleVerseStyle(JSON.parse(savedVerseStyle));
    } catch (e) {
        console.warn('Failed to load verse style:', e);
    }
}

// BG Logic removed

// --- STYLE HANDLER ---
function handleStyle(data) {
    const { target, style } = data;
    const r = document.documentElement;

    // Map internal names to CSS Variables prefix
    // center -> --c-, title -> --t-, bl -> --bl-, br -> --br-, cb -> --cb-
    const prefixMap = {
        center: '--c-',
        title: '--t-',
        bl: '--bl-',
        br: '--br-',
        cb: '--cb-'
    };

    const p = prefixMap[target];
    if (!p) return;

    // Apply CSS Variables
    if (style.w !== undefined) {
        // En modo Auto, usamos 'fit-content' para que abrace el texto
        const finalW = style.autoW ? 'fit-content' : style.w + 'px';
        r.style.setProperty(p + 'w', finalW);

        // TRUCO MAESTRO: Liberar el 'candado' max-width en modo auto
        // Si es auto, max-width = 95% de la pantalla. Si no, es el ancho fijo.
        const maxW = style.autoW ? '90vw' : style.w + 'px';
        r.style.setProperty(p + 'max-w', maxW);
    }
    if (style.x !== undefined) r.style.setProperty(p + 'x', style.x + 'px');
    if (style.y !== undefined) r.style.setProperty(p + 'y', style.y + 'px');
    if (style.h !== undefined) r.style.setProperty(p + 'h', style.h + 'px');

    // Padding X/Y
    if (style.padX !== undefined) r.style.setProperty(p + 'pad-x', style.padX + 'px');
    if (style.padY !== undefined) r.style.setProperty(p + 'pad-y', style.padY + 'px');

    // Radius (Redondez) DIRECTA (Fail-safe)
    if (style.radius !== undefined) {
        r.style.setProperty(p + 'radius', style.radius + 'px');
        // Fuerza bruta: Aplicar directo al panel para evitar problemas de variables
        const u = document.getElementById('unit-' + target);
        if (u) {
            const gp = u.querySelector('.glass-panel');
            if (gp) gp.style.borderRadius = style.radius + 'px';
        }
    }

    // Scale (Zoom)
    if (style.scale !== undefined) {
        r.style.setProperty(p + 'scale', style.scale);
    }

    if (style.op !== undefined) r.style.setProperty(p + 'op', style.op);

    // BADGE CONFIG (Solo aplica a CENTER)
    if (target === 'center') {
        if (style.badgeX !== undefined) r.style.setProperty('--badge-x', style.badgeX + 'px');
        if (style.badgeY !== undefined) r.style.setProperty('--badge-y', style.badgeY + 'px');
        if (style.badgeScale !== undefined) r.style.setProperty('--badge-scale', style.badgeScale);
        if (style.badgeRadius !== undefined) r.style.setProperty('--badge-radius', style.badgeRadius + 'px');
        if (style.badgeOp !== undefined) r.style.setProperty('--badge-opacity', style.badgeOp); // Usamos variable dedicada
    }

    // Custom Font Size Storage
    if (style.fs !== undefined) {
        if (!state.customFS) state.customFS = {};
        state.customFS[target] = style.fs;
    }

    // Force sync immediately
    // syncBackgroundPositions(); // REMOVED (Deprecated)

    // AUTO-RESIZE TRIGGER (Universal)
    // Siempre ejecutar resize cuando cambian dimensiones o padding
    if (style.w !== undefined || style.h !== undefined || style.padX !== undefined || style.padY !== undefined || style.fs !== undefined) {
        setTimeout(() => resizeText(target), 50); // 50ms para asegurar que DOM se actualiza
    }
}


// --- CORE: Manejar Actualizaci√≥n ---
function handleUpdate(payload) {
    if (!payload) return;

    // 1. Actualizar Textos
    if (payload.text) {
        Object.keys(payload.text).forEach(key => {
            const elTxt = el[`txt${capitalize(key)}`];
            const elUnit = el[key];

            if (elTxt) {
                // SKIP if field is not in payload (undefined means "don't touch it")
                if (payload.text[key] === undefined) {
                    console.log(`OVERLAY: Skipping ${key} (not in payload)`);
                    return;
                }

                console.log(`OVERLAY: Updating ${key}:`, payload.text[key]);

                let rawT = payload.text[key] || '';
                // PROCESAR RESALTADO: *texto* -> <span class="highlight">texto</span>
                let styledT = rawT.replace(/\*(.*?)\*/g, '<span class="highlight">$1</span>');

                // Si es el CENTRO y ya est√° visible
                if (key === 'center' && elUnit && elUnit.classList.contains('is-shown') && elTxt.innerHTML !== styledT) {

                    // SMART CHECK ROBUSTO:
                    // Limpiamos TODO lo que no sea letra o n√∫mero. Si el esqueleto es igual, NO animamos.
                    // Esto ignora espacios, saltos de l√≠nea, <br>, y tags HTML.

                    const clean = (str) => str.replace(/<[^>]*>/g, '').replace(/[^a-zA-Z0-9]/g, '');

                    const curSkel = clean(elTxt.innerHTML);
                    const newSkel = clean(rawT.replace(/\*/g, '')); // Quitamos asteriscos del input raw

                    if (curSkel === newSkel) {
                        // 1. SOLO FORMATO (Highlight) -> CAMBIO INSTANT√ÅNEO
                        elTxt.innerHTML = styledT;
                        // Opcional: Agregar clase 'shake' o algo sutil si se quiere feedback
                    } else {
                        // 2. CAMBIO DE TEXTO -> ANIMACI√ìN DE CINE (Blur)

                        // 1. Exit Animation
                        elTxt.classList.remove('text-enter');
                        elTxt.classList.add('text-exit');

                        // 2. Wait & Swap
                        setTimeout(() => {
                            // OCULTAR antes de cambiar (solo center)
                            if (key === 'center') elTxt.style.visibility = 'hidden';
                            elTxt.innerHTML = styledT;
                            // DOBLE RAF + setTimeout para asegurar render
                            requestAnimationFrame(() => {
                                requestAnimationFrame(() => {
                                    setTimeout(() => resizeText(key), 50);
                                });
                            });

                            // 3. Enter Animation
                            elTxt.classList.remove('text-exit');
                            elTxt.classList.add('text-enter');
                        }, 200); // 200ms match CSS kfBlurOut
                    }
                } else {
                    // Actualizaci√≥n Directa (Inicial o Invisible)
                    if (elTxt.innerHTML !== styledT) {
                        // OCULTAR antes de cambiar para evitar parpadeo (solo center)
                        if (key === 'center') elTxt.style.visibility = 'hidden';
                        elTxt.innerHTML = styledT;
                        // DOBLE RAF + setTimeout para asegurar render completo
                        requestAnimationFrame(() => {
                            requestAnimationFrame(() => {
                                setTimeout(() => resizeText(key), 50);
                            });
                        });
                        // Asegurar que entre animado si acaba de aparecer
                        if (key === 'center') elTxt.classList.add('text-enter');
                    }
                }
            }
        });
    }

    // --- VERSE MODE LOGIC (Full Screen Reading) ---
    if (payload.isVerse !== undefined) {
        const isMode = payload.isVerse;
        console.log('VERSE MODE:', isMode, 'verseData:', payload.verseData);

        if (isMode) {
            console.log("VERSE MODE ACTIVE");
        } else {
            console.log("CAST MODE ACTIVE");
        }

        if (isMode) {
            // ENTER OR UPDATE VERSE MODE
            document.body.classList.add('mode-verse');

            if (payload.verseData) {
                const verseTextEl = document.getElementById('verse-text');
                const verseCiteEl = document.getElementById('verse-citation');

                if (verseTextEl && payload.verseData.text) {
                    const cleanNew = payload.verseData.text.trim();
                    const cleanOld = verseTextEl.innerHTML.trim();

                    if (cleanNew !== cleanOld) {
                        const hasExistingContent = cleanOld !== '';
                        if (hasExistingContent) {
                            verseTextEl.style.transition = 'transform 0.3s ease-in, opacity 0.3s ease-in';
                            verseTextEl.style.transform = 'scale(0.8)';
                            verseTextEl.style.opacity = '0';
                            setTimeout(() => {
                                verseTextEl.innerHTML = payload.verseData.text;
                                verseTextEl.style.opacity = '0';
                                verseTextEl.style.transform = 'scale(1.2)';
                                fitVerseText();
                                setTimeout(() => fitVerseText(), 400);
                                setTimeout(() => {
                                    verseTextEl.style.transition = 'transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.4s ease-out';
                                    verseTextEl.style.transform = 'scale(1)';
                                    verseTextEl.style.opacity = '1';
                                }, 50);
                            }, 300);
                        } else {
                            verseTextEl.innerHTML = payload.verseData.text;
                            verseTextEl.style.opacity = '0';
                            verseTextEl.style.transform = 'scale(1)';
                            fitVerseText();
                            setTimeout(() => fitVerseText(), 400);
                            setTimeout(() => {
                                verseTextEl.style.transition = 'opacity 0.4s ease-out';
                                verseTextEl.style.opacity = '1';
                            }, 50);
                        }
                    }

                    if (verseCiteEl && payload.verseData.citation) {
                        verseCiteEl.innerText = payload.verseData.citation;
                    }
                }
            }
        } else {
            // EXIT VERSE MODE
            document.body.classList.remove('mode-verse');

            // Clear verse layer content AFTER animation completes
            setTimeout(() => {
                const verseTextEl = document.getElementById('verse-text');
                const verseCiteEl = document.getElementById('verse-citation');
                if (verseTextEl) verseTextEl.innerHTML = '';
                if (verseCiteEl) verseCiteEl.innerText = '';
            }, 900);
        }
    }

    // 2. Actualizar Visibilidad (Show/Hide)
    if (payload.show) {
        Object.keys(payload.show).forEach(key => {
            let shouldShow = payload.show[key];
            const unit = el[key];
            const textContent = payload.text ? payload.text[key] : null;

            if (!unit) return;

            // AUTO-HIDE: Si el texto est√° vac√≠o, forzar ocultar (salvo que sea el Centro y queramos el globo vac√≠o)
            if (key !== 'center' && (!textContent || textContent.trim() === '')) {
                shouldShow = false;
            }

            const isCurrentlyShown = unit.classList.contains('is-shown');

            if (shouldShow) {
                if (isCurrentlyShown) {
                    const triggers = Array.isArray(payload.triggerAnim) ? payload.triggerAnim : [payload.triggerAnim];
                    if (triggers.includes(key)) {
                        // SOLO animamos el CENTRO al actualizar
                        // El resto (T√≠tulo, Predicador, Cita) se quedan quietos si ya est√°n visibles
                        // if (key === 'center') playAnim(unit, 'fx-in'); // REMOVED: Evita parpadeo al cambiar texto (seamless)
                    }
                } else {
                    unit.classList.remove('is-hidden');
                    unit.classList.add('is-shown');
                    playAnim(unit, 'fx-in');
                }
            } else {
                if (isCurrentlyShown) {
                    unit.classList.remove('is-shown');
                    unit.classList.add('is-hidden');
                    playAnim(unit, 'fx-out');
                }
            }
        });
    }
}

// --- TEXT FIT ENGINE (SOLUCI√ìN DEFINITIVA CON ELEMENTO TEMPORAL) ---
function resizeText(key) {
    // SOLO el Mensaje Central debe auto-ajustar su tama√±o
    if (key !== 'center') {
        console.log('üîß resizeText: Ignorado para', key, '(solo funciona en center)');
        return;
    }

    console.log('üîß resizeText llamado para:', key);
    const unit = el[key];
    if (!unit) {
        console.warn('‚ö†Ô∏è Unit no encontrada:', key);
        return;
    }

    const panel = unit.querySelector('.glass-panel');
    const textEl = el[`txt${capitalize(key)}`];

    if (!textEl || !panel) {
        console.warn('‚ö†Ô∏è textEl o panel no encontrado');
        return;
    }

    // 1. Tama√±os base
    const baseSizes = { center: 56, title: 46, bl: 32, br: 32, cb: 32 };
    const maxFontSize = (state.customFS && state.customFS[key]) ? state.customFS[key] : (baseSizes[key] || 56);

    // 2. Espacio disponible (con padding)
    const cs = window.getComputedStyle(panel);
    const padTop = parseFloat(cs.paddingTop) || 0;
    const padBottom = parseFloat(cs.paddingBottom) || 0;
    const padLeft = parseFloat(cs.paddingLeft) || 0;
    const padRight = parseFloat(cs.paddingRight) || 0;

    const availableWidth = panel.clientWidth - padLeft - padRight;
    const availableHeight = panel.clientHeight - padTop - padBottom;

    console.log('üìê Espacio disponible:', { availableWidth, availableHeight, padTop, padBottom, padLeft, padRight });

    if (availableHeight <= 10 || availableWidth <= 10) {
        console.warn('‚ö†Ô∏è Espacio muy peque√±o');
        return;
    }

    // 3. Crear elemento temporal para medir (SIN flexbox interferencia)
    const measurer = document.createElement('div');
    measurer.style.position = 'absolute';
    measurer.style.visibility = 'hidden';
    measurer.style.width = availableWidth + 'px';
    measurer.style.maxWidth = availableWidth + 'px';
    measurer.style.maxHeight = availableHeight + 'px';
    measurer.style.fontFamily = window.getComputedStyle(textEl).fontFamily;
    measurer.style.letterSpacing = window.getComputedStyle(textEl).letterSpacing;
    measurer.style.textAlign = 'center';
    measurer.style.wordWrap = 'break-word';
    measurer.style.whiteSpace = 'normal'; // Permitir wrap
    measurer.style.display = 'block';
    measurer.style.boxSizing = 'border-box';
    measurer.style.overflow = 'visible'; // Para medir correctamente
    measurer.innerHTML = textEl.innerHTML;
    document.body.appendChild(measurer);

    // 4. NUEVA L√ìGICA: Empezar con tama√±o base, solo reducir si no cabe
    let currentSize = maxFontSize;
    measurer.style.fontSize = currentSize + 'px';
    measurer.style.lineHeight = '1.1';

    // Si cabe con el tama√±o base, √∫salo
    if (measurer.scrollWidth <= (availableWidth + 2) && measurer.scrollHeight <= (availableHeight + 2)) {
        console.log('‚úÖ Cabe con tama√±o base:', currentSize + 'px');
        document.body.removeChild(measurer);
        textEl.style.fontSize = currentSize + 'px';
        textEl.style.lineHeight = '1.1';
        // MOSTRAR si es center (estaba oculto desde handleUpdate)
        if (key === 'center') textEl.style.visibility = 'visible';
        return;
    }

    // Si NO cabe, buscar el tama√±o m√°s peque√±o que funcione
    let min = 10;
    let max = maxFontSize;
    let optimal = min;

    while (min <= max) {
        const mid = Math.floor((min + max) / 2);
        measurer.style.fontSize = mid + 'px';
        measurer.style.lineHeight = '1.1';

        const fits = (measurer.scrollWidth <= (availableWidth + 2) && measurer.scrollHeight <= (availableHeight + 2));

        if (fits) {
            optimal = mid;
            min = mid + 1;
        } else {
            max = mid - 1;
        }
    }

    // 5. Limpiar elemento temporal
    document.body.removeChild(measurer);

    // 6. Aplicar tama√±o final con margen de seguridad
    const finalSize = Math.max(optimal - 4, 10);
    textEl.style.fontSize = finalSize + 'px';
    textEl.style.lineHeight = '1.1';

    console.log('‚ö†Ô∏è Texto reducido a:', finalSize + 'px', 'porque no cab√≠a en', maxFontSize + 'px');

    // MOSTRAR si es center (estaba oculto desde handleUpdate)
    if (key === 'center') textEl.style.visibility = 'visible';
}

// --- ANIMATION ENGINE ---
function playAnim(element, animName) {
    // Resetear animaci√≥n clonando o quitando clase
    element.classList.remove('fx-in', 'fx-out', 'fx-pulse', 'fx-pulse-heavy');
    void element.offsetWidth; // Trigger Reflow (Magic)
    element.classList.add(animName);
}

// Sync Logic removed

// --- UTILS ---
function capitalize(s) { return s.charAt(0).toUpperCase() + s.slice(1); }
function applyStyles(styles) {
    // Ejemplo: styles.cHeight -> --c-height
    const root = document.documentElement;
    if (styles.cWidth) root.style.setProperty('--c-width', styles.cWidth);
    if (styles.cHeight) root.style.setProperty('--c-height', styles.cHeight);
    if (styles.offY) {
        // Ajustar margen top del centro para moverlo
        // Esto requiere l√≥gica m√°s compleja si usamos transform, 
        // pero por ahora modificaremos el marginTop
        // Pendiente para v1.1
    }
}
// --- INIT STRUCTURE ---
function initBorderGlow() {
    document.querySelectorAll('.glass-panel').forEach(panel => {
        if (!panel.querySelector('.border-glow')) {
            const glow = document.createElement('div');
            glow.className = 'border-glow';
            panel.appendChild(glow);
        }
    });
}
initBorderGlow();

// --- AUTO-FIT VERSE TEXT ---
function fitVerseText() {
    const verseTextEl = document.getElementById('verse-text');
    if (!verseTextEl || !verseTextEl.innerHTML) return;

    const panel = document.querySelector('.verse-glass-panel');
    if (!panel) return;

    // Get real computed padding
    const computedStyle = window.getComputedStyle(verseTextEl);
    const padX = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);
    const padY = parseFloat(computedStyle.paddingTop) + parseFloat(computedStyle.paddingBottom);

    // Available space inside the panel
    const availableWidth = (panel.clientWidth || window.innerWidth * 0.9) - padX;
    const availableHeight = (panel.clientHeight || window.innerHeight * 0.8) - padY - 60; // Extra room for citation

    if (availableWidth <= 0 || availableHeight <= 0) return;

    let minSize = 20;
    let maxSize = 500;
    let optimalSize = minSize;

    // Measurement tool
    const temp = document.createElement('div');
    temp.style.position = 'absolute';
    temp.style.visibility = 'hidden';
    temp.style.width = availableWidth + 'px';
    temp.style.fontFamily = 'Bebas Neue, sans-serif';
    temp.style.lineHeight = '1.15';
    temp.style.textTransform = 'uppercase';
    temp.style.wordWrap = 'break-word';
    temp.style.whiteSpace = 'normal';
    temp.style.textAlign = 'center';
    temp.innerHTML = verseTextEl.innerHTML;
    document.body.appendChild(temp);

    // Binary search for size
    while (minSize <= maxSize) {
        const midSize = Math.floor((minSize + maxSize) / 2);
        temp.style.fontSize = midSize + 'px';

        if (temp.scrollHeight <= availableHeight) {
            optimalSize = midSize;
            minSize = midSize + 1;
        } else {
            maxSize = midSize - 1;
        }
    }

    document.body.removeChild(temp);
    verseTextEl.style.fontSize = optimalSize + 'px';
}

// Re-fit text when window resizes or verse style changes
window.addEventListener('resize', () => {
    if (document.body.classList.contains('mode-verse')) {
        fitVerseText();
    }
});
